<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AggregateException_ctor_DefaultMessage" xml:space="preserve">
    <value>One or more errors occurred.</value>
  </data>
  <data name="AggregateException_ctor_InnerExceptionNull" xml:space="preserve">
    <value>An element of innerExceptions was null.</value>
  </data>
  <data name="AggregateException_ToString" xml:space="preserve">
    <value>{0}{1}---&gt; (Inner Exception #{2}) {3}{4}{5}</value>
  </data>
  <data name="CancellationTokenSource_Disposed" xml:space="preserve">
    <value>The CancellationTokenSource has been disposed.</value>
  </data>
  <data name="CancellationToken_CreateLinkedToken_TokensIsEmpty" xml:space="preserve">
    <value>No tokens were supplied.</value>
  </data>
  <data name="CancellationToken_SourceDisposed" xml:space="preserve">
    <value>The CancellationTokenSource associated with this CancellationToken has been disposed.</value>
  </data>
  <data name="ConcurrentCollection_SyncRoot_NotSupported" xml:space="preserve">
    <value>The SyncRoot property may not be used for the synchronization of concurrent collections.</value>
  </data>
  <data name="ConcurrentDictionary_ArrayIncorrectType" xml:space="preserve">
    <value>The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array.</value>
  </data>
  <data name="ConcurrentDictionary_ArrayNotLargeEnough" xml:space="preserve">
    <value>The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array.</value>
  </data>
  <data name="ConcurrentDictionary_CapacityMustNotBeNegative" xml:space="preserve">
    <value>The capacity argument must be greater than or equal to zero.</value>
  </data>
  <data name="ConcurrentDictionary_ConcurrencyLevelMustBePositive" xml:space="preserve">
    <value>The concurrencyLevel argument must be positive.</value>
  </data>
  <data name="ConcurrentDictionary_IndexIsNegative" xml:space="preserve">
    <value>The index argument is less than zero.</value>
  </data>
  <data name="ConcurrentDictionary_ItemKeyIsNull" xml:space="preserve">
    <value>TKey is a reference type and item.Key is null.</value>
  </data>
  <data name="ConcurrentDictionary_KeyAlreadyExisted" xml:space="preserve">
    <value>The key already existed in the dictionary.</value>
  </data>
  <data name="ConcurrentDictionary_SourceContainsDuplicateKeys" xml:space="preserve">
    <value>The source argument contains duplicate keys.</value>
  </data>
  <data name="ConcurrentDictionary_TypeOfKeyIncorrect" xml:space="preserve">
    <value>The key was of an incorrect type for this dictionary.</value>
  </data>
  <data name="ConcurrentDictionary_TypeOfValueIncorrect" xml:space="preserve">
    <value>The value was of an incorrect type for this dictionary.</value>
  </data>
  <data name="OperationCanceled" xml:space="preserve">
    <value>The operation was canceled.</value>
  </data>
  <data name="TaskAwaiter_TaskNotCompleted" xml:space="preserve">
    <value>The awaited task has not yet completed.</value>
  </data>
  <data name="TaskCanceledException_ctor_DefaultMessage" xml:space="preserve">
    <value>A task was canceled.</value>
  </data>
  <data name="TaskCompletionSourceT_TrySetException_NoExceptions" xml:space="preserve">
    <value>The exceptions collection was empty.</value>
  </data>
  <data name="TaskCompletionSourceT_TrySetException_NullException" xml:space="preserve">
    <value>The exceptions collection included at least one null element.</value>
  </data>
  <data name="TaskExceptionHolder_UnhandledException" xml:space="preserve">
    <value>A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread.</value>
  </data>
  <data name="TaskExceptionHolder_UnknownExceptionType" xml:space="preserve">
    <value>(Internal)Expected an Exception or an IEnumerable&lt;Exception&gt;</value>
  </data>
  <data name="TaskSchedulerException_ctor_DefaultMessage" xml:space="preserve">
    <value>An exception was thrown by a TaskScheduler.</value>
  </data>
  <data name="TaskScheduler_ExecuteTask_TaskAlreadyExecuted" xml:space="preserve">
    <value>ExecuteTask may not be called for a task which was already executed.</value>
  </data>
  <data name="TaskScheduler_ExecuteTask_WrongTaskScheduler" xml:space="preserve">
    <value>ExecuteTask may not be called for a task which was previously queued to a different TaskScheduler.</value>
  </data>
  <data name="TaskScheduler_FromCurrentSynchronizationContext_NoCurrent" xml:space="preserve">
    <value>The current SynchronizationContext may not be used as a TaskScheduler.</value>
  </data>
  <data name="TaskScheduler_InconsistentStateAfterTryExecuteTaskInline" xml:space="preserve">
    <value>The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked.</value>
  </data>
  <data name="TaskT_ctor_SelfReplicating" xml:space="preserve">
    <value>It is invalid to specify TaskCreationOptions.SelfReplicating for a Task&lt;TResult&gt;.</value>
  </data>
  <data name="TaskT_DebuggerNoResult" xml:space="preserve">
    <value>{Not yet computed}</value>
  </data>
  <data name="TaskT_SetException_HasAnInitializer" xml:space="preserve">
    <value>A task's Exception may only be set directly if the task was created without a function.</value>
  </data>
  <data name="TaskT_TransitionToFinal_AlreadyCompleted" xml:space="preserve">
    <value>An attempt was made to transition a task to a final state when it had already completed.</value>
  </data>
  <data name="Task_ContinueWith_ESandLR" xml:space="preserve">
    <value>The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running.</value>
  </data>
  <data name="Task_ContinueWith_NotOnAnything" xml:space="preserve">
    <value>The specified TaskContinuationOptions excluded all continuation kinds.</value>
  </data>
  <data name="Task_ctor_LRandSR" xml:space="preserve">
    <value>(Internal)An attempt was made to create a LongRunning SelfReplicating task.</value>
  </data>
  <data name="Task_Delay_InvalidDelay" xml:space="preserve">
    <value>The value needs to translate in milliseconds to -1 (signifying an infinite timeout), 0 or a positive integer less than or equal to Int32.MaxValue.</value>
  </data>
  <data name="Task_Delay_InvalidMillisecondsDelay" xml:space="preserve">
    <value>The value needs to be either -1 (signifying an infinite timeout), 0 or a positive integer.</value>
  </data>
  <data name="Task_Dispose_NotCompleted" xml:space="preserve">
    <value>A task may only be disposed if it is in a completion state (RanToCompletion, Faulted or Canceled).</value>
  </data>
  <data name="Task_FromAsync_LongRunning" xml:space="preserve">
    <value>It is invalid to specify TaskCreationOptions.LongRunning in calls to FromAsync.</value>
  </data>
  <data name="Task_FromAsync_PreferFairness" xml:space="preserve">
    <value>It is invalid to specify TaskCreationOptions.PreferFairness in calls to FromAsync.</value>
  </data>
  <data name="Task_FromAsync_SelfReplicating" xml:space="preserve">
    <value>It is invalid to specify TaskCreationOptions.SelfReplicating in calls to FromAsync.</value>
  </data>
  <data name="Task_FromAsync_TaskManagerShutDown" xml:space="preserve">
    <value>FromAsync was called with a TaskManager that had already shut down.</value>
  </data>
  <data name="Task_MultiTaskContinuation_EmptyTaskList" xml:space="preserve">
    <value>The tasks argument contains no tasks.</value>
  </data>
  <data name="Task_MultiTaskContinuation_FireOptions" xml:space="preserve">
    <value>It is invalid to exclude specific continuation kinds for continuations off of multiple tasks.</value>
  </data>
  <data name="Task_MultiTaskContinuation_NullTask" xml:space="preserve">
    <value>The tasks argument included a null value.</value>
  </data>
  <data name="Task_RunSynchronously_AlreadyStarted" xml:space="preserve">
    <value>RunSynchronously may not be called on a task that was already started.</value>
  </data>
  <data name="Task_RunSynchronously_Continuation" xml:space="preserve">
    <value>RunSynchronously may not be called on a continuation task.</value>
  </data>
  <data name="Task_RunSynchronously_Promise" xml:space="preserve">
    <value>RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method.</value>
  </data>
  <data name="Task_RunSynchronously_TaskCompleted" xml:space="preserve">
    <value>RunSynchronously may not be called on a task that has already completed.</value>
  </data>
  <data name="Task_Start_AlreadyStarted" xml:space="preserve">
    <value>Start may not be called on a task that was already started.</value>
  </data>
  <data name="Task_Start_ContinuationTask" xml:space="preserve">
    <value>Start may not be called on a continuation task.</value>
  </data>
  <data name="Task_Start_Promise" xml:space="preserve">
    <value>Start may not be called on a promise-style task.</value>
  </data>
  <data name="Task_Start_TaskCompleted" xml:space="preserve">
    <value>Start may not be called on a task that has completed.</value>
  </data>
  <data name="Task_ThrowIfDisposed" xml:space="preserve">
    <value>The task has been disposed.</value>
  </data>
  <data name="Task_WaitMulti_NullTask" xml:space="preserve">
    <value>The tasks array included at least one null element.</value>
  </data>
  <data name="Lazy_CreateValue_NoParameterlessCtorForT" xml:space="preserve">
    <value>The lazily-initialized type does not have a public, parameterless constructor.</value>
  </data>
  <data name="Lazy_StaticInit_InvalidOperation" xml:space="preserve">
    <value>ValueFactory returned null.</value>
  </data>
  <data name="ManualResetEventSlim_ctor_SpinCountOutOfRange" xml:space="preserve">
    <value>The spinCount argument must be in the range 0 to {0}, inclusive.</value>
  </data>
  <data name="ManualResetEventSlim_ctor_TooManyWaiters" xml:space="preserve">
    <value>There are too many threads currently waiting on the event. A maximum of {0} waiting threads are supported.</value>
  </data>
  <data name="ManualResetEventSlim_Disposed" xml:space="preserve">
    <value>The event has been disposed.</value>
  </data>
  <data name="SpinWait_SpinUntil_ArgumentNull" xml:space="preserve">
    <value>The condition argument is null.</value>
  </data>
  <data name="SpinWait_SpinUntil_TimeoutWrong" xml:space="preserve">
    <value>The timeout must represent a value between -1 and Int32.MaxValue, inclusive.</value>
  </data>
  <data name="Task_Start_NullAction" xml:space="preserve">
    <value>Start may not be called on a task with null action.</value>
  </data>
</root>