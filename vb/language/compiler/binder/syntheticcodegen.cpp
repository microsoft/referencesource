//-------------------------------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Generates code for the synthetic methods generated by the compiler.
//
//-------------------------------------------------------------------------------------------------

#include "StdAfx.h"

#if DEBUG
// Forward Declaration
const CHAR *GetSyntheticContextName(SyntheticKind Kind);
#endif

void Bindable::GenSyntheticCodeForContainer()
{
    VSASSERT( GetStatusOfGenSyntheticCodeForContainer() != InProgress,
                    "Cycles when doing this task!!");

    if (GetStatusOfGenSyntheticCodeForContainer() == Done)
    {
        return;
    }

    if (CurrentContainer()->IsEnum() ||
        CurrentContainer()->IsNamespace())
    {
        SetStatusOfGenSyntheticCodeForContainer(Done);
        return;
    }

    SetStatusOfGenSyntheticCodeForContainer(InProgress);

    BCITER_CHILD_ALL Members(CurrentContainer());

    for (BCSYM_NamedRoot *Member = Members.GetNext();
         Member;
         Member = Members.GetNext())
    {
        if (Member->IsSyntheticMethod())
        {
            GenSyntheticCode(Member->PSyntheticMethod());
        }
        else if (Member->IsMember() && !IsSynthetic(Member))
        {
            VerifyAccessExposureForMember(Member->PMember());
        }
    }

    VerifyAccessExposureForGenericParameters(CurrentContainer());

    SetStatusOfGenSyntheticCodeForContainer(Done);
}


/*****************************************************************************
;GenSyntheticCode

Generate the bodies for Main, New, Event hookups, etc.
*****************************************************************************/
void
Bindable::GenSyntheticCode
(
    BCSYM_SyntheticMethod *SyntheticMethod  // [in] the method that we will generate code for
)
{
    // contains the generated synthetic code
    StringBuffer CodeBlock;
    ParseTree::StatementList* ParsedCode = NULL;
    unsigned LocalsCountForParsedCode = 0;

    // We have very bad code that jumps into the middle of an if block.
    // As a result, I've pulled this out rather than refactor this entire method.
    WCHAR *CodeForSynthMethod = NULL;

    // Use large allocation blocks to prevent multiple-reallocs
    CodeBlock.SetAllocationSize(StringBuffer::AllocSize::Large);

    // The constructors are special, the code for them needs to be generated even in the
    // presence of errors because otherwise the class level initializers are not processed
    // thus delaying any errors in them till the other previously detected errors are fixed.
    // The delaying is not a very good model, so instead we always generate the constructor
    // code.
    //
    if (SyntheticMethod->GetSyntheticKind() == SYNTH_New ||
        SyntheticMethod->GetSyntheticKind() == SYNTH_SharedNew)
    {
        // The MyBase.New call for instance constructors will be
        // generated later by semantics.
        //
        // It is better to let it generate the code because then it
        // will realize it is synthetic code and will either do or
        // suppress obsolete checks, etc. as necessary on the
        // synthetic code it generates.
        //

        // In the case of shared constructor, Create an empty constructor
        // method...the compiler will take care of everything else automatically.

        CodeBlock.AppendString( WIDE( "\r\n" ));

#if DEBUG
        goto DumpSyntheticCode;
#endif

        return;
    }

    // Don't generate any code if there are any errors. That way we avoid the problem of errors
    // showing up in Synthetic code. Note for future - if ever we move completely to a container
    // based decompilation, for container based decompilation, we need to see if the container
    // has any errors rather than the sourcefile.
    //
    // This greatly reduces the possibility of errors in synthetic code
    //
    // if the source file containing this method has bindable errors, don't output any code
    if (SourceFilesOfContainerHaveErrorsInCurrentCompilerStep())
    {
        Symbols::SetCode(SyntheticMethod, NULL, 0);
        Symbols::SetParsedCode(SyntheticMethod, NULL, 0);
        return;
    }

    switch(SyntheticMethod->GetSyntheticKind())
    {
        case SYNTH_FormMain:
        {
            GenSynthFormMainCode(SyntheticMethod, &CodeBlock);
            break;
        }

        // Created by Declared in reponse to a WithEvents z as y statement
        // or an AutoProperty statement.
        // All the error output for the WithEvents variable takes place here
        case SYNTH_WithEventsGet:
        case SYNTH_AutoPropertyGet:
        {
            GenSyntheticGetCode(SyntheticMethod, &CodeBlock);
            break;
        }

        // e.g. Public NotOverridable Sub MyEventVariable( _o as EventSourceClass )
        case SYNTH_WithEventsSet:
        case SYNTH_AutoPropertySet:
        {
            GenSyntheticSetCode(SyntheticMethod, &ParsedCode, &LocalsCountForParsedCode);
            break;
        }

        case SYNTH_MyGroupCollectionGet:
        {
            GenMyGroupCollectionGetCode(SyntheticMethod, &CodeBlock);
            break;
        }

        case SYNTH_MyGroupCollectionSet:
        {
            GenMyGroupCollectionSetCode(SyntheticMethod, &CodeBlock);
            break;
        }

        // Created by Declared in response to an Event E statement
        // the code will be: [<variablename>] = [<variablename>].Combine([<variablename>], obj )
        case SYNTH_AddEvent:
        {
            GenAddEventCode(SyntheticMethod, &CodeBlock);
            break;
        }

        // Created by Declared in response to an Event E statement
        // the code will be: [<variablename>] = [<variablename>].Remove([<variablename>],obj )
        case SYNTH_RemoveEvent:
        {
            GenRemoveEventCode(SyntheticMethod, &CodeBlock);
            break;
        }

        case SYNTH_TransientSymbol:
        {
            CodeBlock.AppendString(WIDE( "\r\n" ));
            break;
        }

        case SYNTH_TransientNoIntCheckSymbol:
        {
            CodeBlock.AppendString(WIDE( "\r\n" ));
            break;
        }

#if IDE
        case SYNTH_IterateENCTrackingList:
        {
            GenIterateENCTrackingListCode(SyntheticMethod, &CodeBlock);
            break;
        }

        case SYNTH_ENCUpdateHandler:
        {
            CodeBlock.AppendString(WIDE( "\r\n" ));
            break;
        }

        case SYNTH_ENCHiddenRefresh:
        {
            CodeBlock.AppendString(WIDE( "\r\n" ));
            break;
        }

        case SYNTH_ENCSharedHiddenRefresh:
        {
            CodeBlock.AppendString(WIDE( "\r\n" ));
            break;
        }

        case SYNTH_AddToENCTrackingList:
        {
            GenAddToENCTrackingListCode(SyntheticMethod, &CodeBlock);
            break;
        }
#endif IDE

        default:

            VSFAIL("Unknown Synthetic kind");
            break;
    }


    if (ParsedCode)
    {
        Symbols::SetParsedCode(
            SyntheticMethod,
            ParsedCode,
            LocalsCountForParsedCode);
    }
    else
    {
        // Allocate a copy of the code that we can give to the synthetic method

        unsigned CodeBlockLength = CodeBlock.GetStringLength();

        if (CodeBlockLength > 0)
        {
            // Microsoft 9/13/2004: Don't need to check allocation for overflow, since allocation size would match that of a string already allocated.
            CodeForSynthMethod = CodeBlock.AllocateBufferAndCopy(CurrentAllocator());
        }
        else
        {
            CodeForSynthMethod = NULL;
        }

        Symbols::SetCode(
            SyntheticMethod,
            CodeForSynthMethod,
            CodeBlockLength > 0 ? CodeBlockLength : 0 );

        // Dump code in Debug builds when the dump.syntheticcode option is specified
#if DEBUG

    DumpSyntheticCode:

        if (VSFSWITCH(fDumpSyntheticCode))
        {

            if (CodeForSynthMethod == NULL)
            {
                unsigned CodeBlockLengthDbg = CodeBlock.GetStringLength();

                if (CodeBlockLengthDbg > 0)
                {
                    // Microsoft 9/13/2004: Don't need to check allocation for overflow, since allocation size would match that of a string already allocated.
                    CodeForSynthMethod = CodeBlock.AllocateBufferAndCopy(CurrentAllocator());
                }
            }

            StringBuffer SynthSignatureString;

            SyntheticMethod->GetBasicRep(
                CurrentCompilerInstance(),
                CurrentContainer(),
                &SynthSignatureString,
                NULL,
                SyntheticMethod->GetName());

            DebPrintf( "[%S] %S\n",
                        GetSyntheticContextName(
                            SyntheticMethod->GetSyntheticKind()),
                            SynthSignatureString.GetString());

            DebPrintf( "%S\n", CodeBlock.GetString());

            if (CodeBlockLength > 0)
            {
                DebPrintf( "{\n" );
                if (CodeForSynthMethod == NULL)
                {
                    DebPrintf( "<no synthetic code>\n" );
                }
                else
                {
                    DebPrintf( "%S", CodeForSynthMethod );
                }
                DebPrintf( "}\n\n" );
            }
        }
#endif DEBUG
    }
}
/*****************************************************************************
;GenSynthFormMainCode

Generate the synthetic code for Form Main
*****************************************************************************/
void
Bindable::GenSynthFormMainCode
(
    BCSYM_SyntheticMethod *SyntheticMethod, // [in] the method that we will generate code for
    StringBuffer * CodeBlock // [out] "[foo] = _foo" - for a synthetic method named Foo
)
{

    // If we're not derived from form, then don't generate anything, the
    // sub main code will catch this and report an error.

    BCSYM_Class *pContainingClass = SyntheticMethod->GetContainingClass();
    VSASSERT( pContainingClass &&
              pContainingClass->IsClass() &&
              pContainingClass->HasLocation(),
                L"Bad Container for Synthetic Sub Main!");

    VSASSERT( pContainingClass->GetParent() &&
              pContainingClass->GetParent()->IsContainer(),
                L"Bad Container for Synthetic Sub Main!");

    // Startup generics forms are unsupported. Error is given when looking for the entry point.
    //
    // 




    if (!IsGenericOrHasGenericParent(pContainingClass) &&
        SeeIfWindowsFormClass(pContainingClass, CurrentCompilerInstance()))
    {
        bool NameIsBad = true;

        // First, we need to run the name we are getting from SyntheticMethod->GetContainingClass()->GetName()
        // through semantics, that way, we should know if there are any errors with the code we are going to
        // generate or not. If we don't do that, we will catch the error when running PEBuilder, and we will
        // end up reporting errors on the synthetic code.
        //
        BCSYM_NamedRoot *pBoundName =
            Semantics::EnsureNamedRoot
            (
                Semantics::InterpretName
                (
                    pContainingClass->GetName(),
                    *(pContainingClass->GetLocation()),
                    pContainingClass->GetParent()->PContainer()->GetHash(),
                    NULL,   // No Type parameter lookup
                    NameSearchTypeReferenceOnly | NameSearchIgnoreExtensionMethods,
                    NULL,
                    CurrentCompilerInstance(),
                    CurrentCompilerHost(),
                    pContainingClass->GetSourceFile(),
                    NameIsBad,
                    NULL, /* No binding context required */
                    NULL,
                    0
                )
            );

        if (pBoundName && !pBoundName->IsBad() && !NameIsBad)
        {
            if (pContainingClass->GetSourceFile()->GetProject()->m_StartupMyFormFactory)
            {
                CodeBlock->AppendString( WIDE( "Global.System.Windows.Forms.Application.Run(" ));
                CodeBlock->AppendSTRING(pContainingClass->GetGlobalQualifiedName());
                CodeBlock->AppendChar(L')');
            }
            else
            {
                // build the code for the Synthetic Sub Main
                CodeBlock->AppendString( WIDE( "Global.System.Windows.Forms.Application.Run(New " ));

                CodeBlock->AppendSTRING(
                    MakeSafeQualifiedName(
                    CurrentCompilerInstance(),
                    pContainingClass->GetName()));

                CodeBlock->AppendChar(L')');
            }
        }
    }
}

//-------------------------------------------------------------------------------------------------
// ;GenSyntheticGetCode
//
// Generates the synthetic code for a synthetic get which is created by Declared in
// response to a WithEvents z as y statement or an auto property.
//
// Given "WithEvents foo as EventSource" or "Property foo as DataType"
// When handling a WithEvent variable  or an auto property defined in the same class, emits:
//     return _foo
// When handling a WithEvent variable defined in a base class, emits:
//     return mybase.foo
//-------------------------------------------------------------------------------------------------
void
Bindable::GenSyntheticGetCode
(
    _In_ BCSYM_SyntheticMethod *pSyntheticGet, // the method that we will generate code for
    _Out_ StringBuffer * pCodeBlockText // code for the synthetic get
)
{

    VSASSERT( pSyntheticGet != NULL, "Invalid input");

    STRING *pNameOfMemberThatCreatedGet = pSyntheticGet->GetAssociatedPropertyDef()->GetName();

    // Do we just need to forward the call to the base class?
    if (pSyntheticGet->IsCallBaseFirst())
    {
        pCodeBlockText->AppendString( WIDE("return MyBase."));
        pCodeBlockText->AppendSTRING( pNameOfMemberThatCreatedGet );
    }
    else
    {
        pCodeBlockText->AppendString( WIDE("return _"));
        pCodeBlockText->AppendSTRING( pNameOfMemberThatCreatedGet );
    }
    pCodeBlockText->AppendString( WIDE("\r\n" ));
}

//-------------------------------------------------------------------------------------------------
// ;GenSyntheticSetCode
//
// Generates code for a WithEventsSet or an auto property Set synthetic method 
// (created by Declared in response to a WithEvents z as y statement or an auto property) 
//
// Set handles the hookup of the  event handlers for WithEvents (auto properties do not handle 
// events).
//
// WithEvents var defined in same class as handler
//-----------------------------------------------
// If Not _EventVar Is Nothing Then
//     RemoveHandler _EventVar.[MyEvent], AddressOf [TylerHandles]
// End If
// _EventVar = _o
// If Not _EventVar Is Nothing Then
//    AddHandler _EventVar.[MyEvent], AddressOf [TylerHandles]
// End If
//
// WithEvents var defined in a base class
//--------------------------------------
// If Not MyBase.EventVar Is Nothing Then
//    RemoveHandler MyBase.EventVar.[MyEvent], AddressOf [foo]
// End If
// MyBase.EventVar = _o
// If Not MyBase.EventVar Is Nothing Then
//    AddHandler MyBase.EventVar.[MyEvent], AddressOf [foo]
// End If
//
// AutoProperty
//--------------------------------------
// Me._x = AutoPropertyValue
//
//-------------------------------------------------------------------------------------------------
void
Bindable::GenSyntheticSetCode
(
    _In_ BCSYM_SyntheticMethod *pSyntheticSet, // [in] the method that we will generate code for
    _Out_ ParseTree::StatementList** pSetParsedCode, // [out] the code for the function as parse tree
    _Out_ unsigned* pLocalsCountForParsedCode // [out] The number of locals generated.
)
{
    ThrowIfFalse(pSetParsedCode != NULL); // Check bad out Param passed in.
    ThrowIfFalse(pLocalsCountForParsedCode != NULL);
    *pSetParsedCode = NULL;

    //
    // For withevents not auto properties
    //--------------------------------------------
    // Build the hookup code for the EventSet method, e.g. :
    //  Given: Class2.cls with Public WithEvents myEventVariable as EventSourceClass and an Event MyEvent( x as integer ) in EventSourceClass.cls
    //  Class2.cls:
    // -> Public NotOverridable Property Set myEventVariable( obj as EventSourceClass )
    //        If Not _myEventVariable Is Nothing Then
    //            RemoveHandler _myEventVariable.Event, AddressOf EventHandler
    //        End If  ->wszLineOfCode1
    //        _myEventVariable = _o -> wszLineOfCode2
    //        If Not _myEventVariable Is Nothing Then
    //            AddHandler _myEventVariable.Event, AddressOf EventHandler
    //        End If -> wszLineOfCode3
    //      End Sub
    //
    ParserHelper PH(CurrentAllocator(), Location::GetHiddenLocation());

    // Is this set overriding a Base's Set i.e. is the property overriding a base's property ?
    bool IsOverridingSet = pSyntheticSet->IsCallBaseFirst();

    // Build the code to refer to the Set's variable.
    ParseTree::Expression * pVariableName = NULL;
    if (IsOverridingSet)
    {
        pVariableName = PH.CreateQualifiedExpression(
            PH.CreateMyBaseReference(),
            PH.CreateNameExpression(
                1,
                pSyntheticSet->GetAssociatedPropertyDef()->GetName()));
    }
    else
    {
        StringBuffer VariableNameBuffer;
        VariableNameBuffer.AppendString(L"_");
        VariableNameBuffer.AppendSTRING(pSyntheticSet->GetAssociatedPropertyDef()->GetName());

        pVariableName =
            PH.CreateNameExpression(1, CurrentCompilerInstance()->AddString(&VariableNameBuffer));
    }

    ParseTree::Expression * ParameterExpression = PH.CreateNameExpression(1, pSyntheticSet->GetFirstParam()->GetName());

    ParseTree::Expression * Condition = PH.CreateBinaryExpression(
            ParseTree::Expression::IsNot,
            pVariableName,
            PH.CreateNothingConst());

    ParseTree::Statement * Assignment = PH.CreateAssignment(pVariableName,ParameterExpression);


    // If there are no handlers, then generate only the
    // assignment statement (this will always be the case for auto properties.
    if (!pSyntheticSet->GetHandlerList())
    {
        *pSetParsedCode = PH.CreateStatementList(Assignment);
    }
    else
    {
        ParseTree::StatementList * AssignmentBlock = NULL;
        ParseTree::StatementList * AddCodeBlock = NULL;
        ParseTree::StatementList * RemoveCodeBlock = NULL;

        GenWithEventsSetAddRemoveBlocks(
            pSyntheticSet->GetHandlerList(),
            pVariableName,
            &AssignmentBlock,
            &RemoveCodeBlock,
            &AddCodeBlock,
            pLocalsCountForParsedCode);

        // Generate the complete Remove code
        // If Not <WithEventsVarName> Is Nothing Then\r\n
        //    <RemoveCodeBlock>
        //  End If;
        ParseTree::StatementList * RemoveHandlerSL = PH.CreateIfStatement(
                Condition,
                RemoveCodeBlock /*then*/,
                NULL /*else*/ );

        // Generate the assignment code
        ParseTree::StatementList * AssignmentSL = PH.CreateStatementList(Assignment);

        // Generate the complete Add code
        // If Not <WithEventsVarName> Is Nothing Then\r\n
        //    <AddCodeBlock>
        //  End If;
        ParseTree::StatementList * AddHandlerSL = PH.CreateIfStatement(
                Condition,
                AddCodeBlock /*then*/,
                NULL /*else*/ );

        PH.JoinStatementList(
            4,
            AssignmentBlock,
            RemoveHandlerSL,
            AssignmentSL,
            AddHandlerSL);

        // Return the first item of the linked statement list.
        *pSetParsedCode = AssignmentBlock;
    }
}

void
Bindable::GenWithEventsSetAddRemoveBlocks
(
    HandlerList *Handlers,
    ParseTree::Expression * WithEventsVariable,
    ParseTree::StatementList** AssignmentBlock,
    ParseTree::StatementList** RemoveHandlerCode,
    ParseTree::StatementList** AddHandlerCode,
    unsigned * LocalsCountForParsedCode
)
{
    ThrowIfNull(AddHandlerCode);
    ThrowIfNull(RemoveHandlerCode);
    ThrowIfNull( LocalsCountForParsedCode );
    *AddHandlerCode = NULL;
    *RemoveHandlerCode = NULL;

    ParserHelper PH(CurrentAllocator(), Location::GetHiddenLocation());

    ParseTree::StatementList * LastAddHandler = NULL;
    ParseTree::StatementList * LastRemoveHandler = NULL;
    ParseTree::StatementList * LastAssignment = NULL;

    unsigned HandleCount = 0;

    for (HandlerList *HandlesEntry = Handlers;
         HandlesEntry;
         HandlesEntry = HandlesEntry->Next )
    {
        ParseTree::Expression * EventReference = NULL;

        if (HandlesEntry->EventSourceProperty)
        {
            // EventReference = <EventVariableName>.<EventSourceProperty>.<EventName>
            // Need to be this particular structure (can't use bound) because eventsements expects this
            // structure explicitly
            EventReference = PH.CreateQualifiedExpression(
                PH.CreateQualifiedExpression(
                    WithEventsVariable,
                    PH.CreateNameExpression(1, HandlesEntry->EventSourceProperty->GetName())),
                PH.CreateNameExpression(1, HandlesEntry->Event->GetName()));
        }
        else
        {
            // EventReference = <EventVariableName>.<EventName>
            EventReference = PH.CreateQualifiedExpression(
                WithEventsVariable,
                PH.CreateNameExpression(1, HandlesEntry->Event->GetName()));
        }

        // AddressOf <EventHandler>
        // Note that the symbol was already referenced in this file, so we do not need to add extra symbol <-> file dependencies
        ParseTree::Expression * AddressOfHandler = PH.CreateAddressOf(PH.CreateBoundSymbol(HandlesEntry->HandlingProc), true);

        // Build the name of the curent variable.
        StringBuffer variableNameBuffer;
        variableNameBuffer.AppendPrintf(L"_Handler$_%X", HandleCount);
        STRING *VariableName = CurrentCompilerInstance()->AddString(&variableNameBuffer);

        DelayedGetDelegateParameter * Parameter = new(*CurrentAllocator()) DelayedGetDelegateParameter(
            HandlesEntry,
            CurrentCompilerInstance(),
            CurrentAllocator(),
            NULL); // GenericBindingCache

        // _Handler$_x = AddressOf <EventHandler>\r\n";
        LastAssignment = PH.AppendToStatementList(
            LastAssignment,
            PH.CreateVariableDeclarationStatement(
                VariableName,
                PH.CreateBoundDelayCalculatedType(&ExtractDelegateFromHandlesEntry, Parameter),
                AddressOfHandler));
        if (*AssignmentBlock == NULL)
        {
            // Return the first item of the linked statement list.
            *AssignmentBlock = LastAssignment;
        }

        // RemoveHandler <EventReference>, _Handler$_x \r\n";
        LastRemoveHandler = PH.AppendToStatementList(
            LastRemoveHandler,
            PH.CreateRemoveHandler(EventReference, PH.CreateNameExpression(1, VariableName)));
        if (*RemoveHandlerCode == NULL)
        {
            // Return the first item of the linked statement list.
            *RemoveHandlerCode = LastRemoveHandler;
        }

        // AddHandler <EventReference>, _Handler$_x \r\n";
        LastAddHandler = PH.AppendToStatementList(
            LastAddHandler,
            PH.CreateAddHandler(EventReference, PH.CreateNameExpression(1, VariableName)));
        if (*AddHandlerCode == NULL)
        {
            // Return the first item of the linked statement list.
            *AddHandlerCode = LastAddHandler;
        }

        HandleCount++;
    }

    *LocalsCountForParsedCode = HandleCount;
}


/*****************************************************************************
;ExtractDelegateFromHandlesEntry

Static helper function that delay retreives the delegate type and resolves the
generics. This is needed for events declared that derive from interfaces since
then semantics will add the type of the delegate and remains GenericBadNamedRoot
until then, this works around it by computing it when the boundtype gets interpreted
wich is after semantics populates the proper type.
*****************************************************************************/
/*static*/
BCSYM *
Bindable::ExtractDelegateFromHandlesEntry
(
    void* VoidParameter
)
{
    DelayedGetDelegateParameter * Parameter = (DelayedGetDelegateParameter*)VoidParameter;
    HandlerList * HandlesEntry = Parameter->m_HandlesEntry;

    BCSYM * DelegateType = ReplaceGenericParametersWithArguments(
        HandlesEntry->Event->GetDelegate(),
        HandlesEntry->EventGenericBindingContext,
        Parameter->m_Symbols);

    return DelegateType;
}

/*****************************************************************************
;GenAddEventCode

Generate the synthetic code for AddEvent (Created by Declared in response to an
Event E statement) which adds a listener to an event generated by this class.

fooEvent=CType(fooEvent.Combine(fooEvent, obj), Project1.Class1.FooEventHandler)
*****************************************************************************/
void
Bindable::GenAddEventCode
(
    BCSYM_SyntheticMethod *SyntheticMethod, // [in] the method that we will generate code for
    StringBuffer *CodeBlockText // [out] "fooEvent=CType(fooEvent.Combine(fooEvent, obj), Project1.Class1.FooEventHandler)"
)
{
    // this is an indicator that this event hookup was defined on an interface
    if (CurrentContainer()->IsInterface())
    {
        return; //don't output any code
    }

    BCSYM_EventDecl *Event = SyntheticMethod->CreatedByEventDecl();
    if (Event->IsBad() || !Event->GetDelegate())
    {
        return;
    }

    STRING *EventName = Event->GetName();
    STRING *ParamName = SyntheticMethod->GetFirstParam()->GetName();

    WCHAR *AddEventCodeTemplate = NULL;
    if (Event->IsWindowsRuntimeEvent())
    {
        // Get the fully qualified name of the Event's Delegate Type
        STRING *EventDelegateTypeName = Event->GetDelegateVariable()->GetType()->PGenericTypeBinding()->GetArgument(0)->GetGlobalQualifiedName();

        AddEventCodeTemplate = L"return Global.System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable(of |1).GetOrCreateEventRegistrationTokenTable([|2Event]).AddEventHandler(|3)\r\n";

        ResStringRepl(
                AddEventCodeTemplate,
                CodeBlockText,
                EventDelegateTypeName,
                EventName,
                ParamName);
    }
    else
    {
        // |1 - Name of the event
        // |2 - AddEvent Method's Parameter Name
        // |3 - Name of the Delegate that the event is typed as
        //L"[<EventName>Event] = CType( [<EventName>Event].Combine([<EventName>Event], <Param1>), <EventDelegateTypeName> )\r\n";
    
        // Get the fully qualified name of the Event's Delegate
        STRING *DelegateName = Event->GetDelegate()->GetGlobalQualifiedName();

        AddEventCodeTemplate = L"[|1Event] = CType( [|1Event].Combine([|1Event], |2), |3 )\r\n";

        ResStringRepl(
                AddEventCodeTemplate,
                CodeBlockText,
                EventName,
                ParamName,
                DelegateName);
    }
}

/*****************************************************************************
;GenRemoveEventCode

Generate the synthetic code for RemoveEvent (created by Declared in response to
an Event E statement) which unhooks an event listener from the class.

fooEvent=CType(fooEvent.Remove( fooEvent, obj), Project1.Class1.fooEventHandler)
*****************************************************************************/
void
Bindable::GenRemoveEventCode
(
    BCSYM_SyntheticMethod *SyntheticMethod, // [in] the method that we will generate code for
    StringBuffer * CodeBlockText // [out] "fooEvent=CType(fooEvent.Remove( fooEvent, obj), Project1.Class1.fooEventHandler)"
)
{
    // this is an indicator that this event hookup was defined on an interface
    if (CurrentContainer()->IsInterface())
    {
        return; //don't output any code
    }

    BCSYM_EventDecl *Event = SyntheticMethod->CreatedByEventDecl();
    if (Event->IsBad() || !Event->GetDelegate())
    {
        return;
    }


    STRING *EventName = Event->GetName();
    STRING *ParamName = SyntheticMethod->GetFirstParam()->GetName();

    WCHAR *RemoveEventCodeTemplate = NULL;
    if (Event->IsWindowsRuntimeEvent())
    {
        // Get the fully qualified name of the Event's Delegate Type
        STRING *EventDelegateTypeName = Event->GetDelegateVariable()->GetType()->PGenericTypeBinding()->GetArgument(0)->GetGlobalQualifiedName();

        RemoveEventCodeTemplate = L"Global.System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable(of |1).GetOrCreateEventRegistrationTokenTable([|2Event]).RemoveEventHandler(|3)\r\n";

        ResStringRepl(
                RemoveEventCodeTemplate,
                CodeBlockText,
                EventDelegateTypeName,
                EventName,
                ParamName);
    }
    else
    {
        // |1 - Name of the evenet
        // |2 - AddEvent Method's Parameter Name
        // |3 - Name of the Delegate that the event is typed as
        //L"[<EventName>Event] = CType( [<EventName>Event].Remove([<EventName>Event], <Param1>), <EventDelegateTypeName> )\r\n";

        // Get the fully qualified name of the Event's Delegate
        STRING *DelegateName = Event->GetDelegate()->GetGlobalQualifiedName();

        RemoveEventCodeTemplate = L"[|1Event] = CType( [|1Event].Remove([|1Event], |2), |3 )\r\n";

        ResStringRepl(
            RemoveEventCodeTemplate,
            CodeBlockText,
            EventName,
            ParamName,
            DelegateName);
    }
}

#if IDE

/*****************************************************************************
;GenIterateENCTrackingListCode

SyncLock __ENCList
    ' Iterate through the list and clear it in one pass. Avoid using RemoveAt
    ' to remove dead weakrefs because that causes O(N^2) performance.
    Dim liveCount As Integer = 0
    For i As Integer = 0 To __ENCList.Count - 1
        Dim target As Global.System.Object =
            CType(__ENCList.Item(i), Global.System.WeakReference).Target

        If target IsNot Nothing Then
            CType(target, ClassName).__ENCUpdateHandlers
         
            If i <> liveCount Then
                __ENCList.Item(liveCount) = __ENCList.Item(i)
            End If
            liveCount += 1
        End If
    Next
    __ENCList.RemoveRange(liveCount, __ENCList.Count - liveCount)
    __ENCList.Capacity = __ENCList.Count
End SyncLock

Please note: __ENCLIst could be an ArrayList or List(Of WeakRefernece) depending on the target you are building for.
*****************************************************************************/
void
Bindable::GenIterateENCTrackingListCode
(
    BCSYM_SyntheticMethod *SyntheticMethod, // [in] the method that we will generate code for
    StringBuffer * CodeBlockText // [out] "the code"
)
{
    VSASSERT(wcscmp(STRING_CONST(CurrentCompilerInstance(), ENCTrackingList), L"__ENCList") == 0,
                "ENCTrackingList lost!!!");

    VSASSERT(wcscmp(STRING_CONST(CurrentCompilerInstance(), ENCUpdateHandlers), L"__ENCUpdateHandlers") == 0,
                "ENCTrackingList lost!!!");

    CodeBlockText->AppendString(
        L"SyncLock __ENCList \r\n"
        L"    Dim liveCount As Integer = 0 \r\n"
        L"    For i As Integer = 0 To __ENCList.Count - 1 \r\n"
        L"        Dim target As Global.System.Object = _ \r\n"
        L"            CType(__ENCList.Item(i), Global.System.WeakReference).Target \r\n"
        L"        If target IsNot Nothing Then \r\n"
        L"            CType(target, ");

    // Get the fully qualified name of the containing class
    STRING *ClassName = CurrentContainer()->GetGlobalQualifiedName();

    CodeBlockText->AppendSTRING(ClassName);

    CodeBlockText->AppendString(
        L").__ENCUpdateHandlers \r\n"
        L"            If i <> liveCount Then \r\n"
        L"                __ENCList.Item(liveCount) = __ENCList.Item(i) \r\n"
        L"            End If \r\n"
        L"            liveCount += 1 \r\n"
        L"        End If \r\n"
        L"    Next \r\n"
        L"    __ENCList.RemoveRange(liveCount, __ENCList.Count - liveCount) \r\n"
        L"    __ENCList.Capacity = __ENCList.Count \r\n"
        L"End SyncLock");
}


/*****************************************************************************
;GenAddToENCTrackingListCode

SyncLock __ENCList
    ' Periodically we need to sweep the list and remove dead weakrefs or we
    ' will leak memory, see Dev10#754155. I suspect this approach is good
    ' enough in practice, although technically the number of leaked weakref
    ' objects could still be equal to the peak number of live objects, in the
    ' worst case. The only way to do better would be to add a finalizer to the
    ' class and have instances remove themselves, which is both more complex
    ' and incurs a larger performance hit (every object with events ends up on
    ' on the GC finalization queue, and we need a different data structure).
    '
    ' To keep amortized O(1) add time, we wait until the list is at capacity
    ' and has to resize itself anyway. At that point we sweep it and remove
    ' dead weakref objects.
    If __ENCList.Count = __ENCList.Capacity Then
        Dim liveCount As Integer = 0
        For i As Integer = 0 To __ENCList.Count - 1
            Dim ref As Global.System.WeakReference = _
                CType(__ENCList.Item(i), Global.System.WeakReference)

            If ref.IsAlive Then
                If i <> liveCount Then
                    __ENCList.Item(liveCount) = __ENCList.Item(i)
                End If
                liveCount += 1
            End If
        Next
        __ENCList.RemoveRange(liveCount, __ENCList.Count - liveCount)
        __ENCList.Capacity = __ENCList.Count
    End If
    __ENCList.Add(New Global.System.WeakReference(Value))
End SyncLock

Please note: __ENCLIst could be an ArrayList or List(Of WeakRefernece) depending on the target you are building for.
*****************************************************************************/
void
Bindable::GenAddToENCTrackingListCode
(
    BCSYM_SyntheticMethod *SyntheticMethod, // [in] the method that we will generate code for
    StringBuffer * CodeBlockText // [out] "the code"
)
{
    VSASSERT(wcscmp(STRING_CONST(CurrentCompilerInstance(), ENCTrackingList), L"__ENCList") == 0,
                "ENCTrackingList lost!!!");

    VSASSERT(wcscmp(STRING_CONST(CurrentCompilerInstance(), ENCUpdateHandlers), L"__ENCUpdateHandlers") == 0,
                "ENCTrackingList lost!!!");

    CodeBlockText->AppendString(
        L"SyncLock __ENCList \r\n"
        L"    If __ENCList.Count = __ENCList.Capacity Then \r\n"
        L"        Dim liveCount As Integer = 0 \r\n"
        L"        For i As Integer = 0 To __ENCList.Count - 1 \r\n"
        L"            Dim ref As Global.System.WeakReference = _ \r\n"
        L"                CType(__ENCList.Item(i), Global.System.WeakReference) \r\n"
        L"            If ref.IsAlive Then \r\n"
        L"                If i <> liveCount Then \r\n"
        L"                    __ENCList.Item(liveCount) = __ENCList.Item(i) \r\n"
        L"                End If \r\n"
        L"                liveCount += 1 \r\n"
        L"            End If \r\n"
        L"        Next \r\n"
        L"        __ENCList.RemoveRange(liveCount, __ENCList.Count - liveCount) \r\n"
        L"        __ENCList.Capacity = __ENCList.Count \r\n"
        L"    End If \r\n"
        L"    __ENCList.Add(New Global.System.WeakReference(Value)) \r\n"
        L"End SyncLock");
}

#endif IDE

/*****************************************************************************
;GenMyCollectioGetCode

Generates the synthetic code for a MyCollection member property <MyGroupCollection()>, ie:
A "My Group Collection" class 'Group' is a class that have the attribute
<MyGroupCollection("base1, base2 ...", "inst_creator1, inst_creator2...", "inst_disposer1, inst_disposer2, ..",
"AliasForMyObjectRootForDefaultInstace1, AliasForMyObjectRootForDefaultInstace2...">
Any other class 'foo' that derives from 'base' becomes a member of 'Group', i.e. a property for handling an instance
of the member is generated inside 'Group'.


*****************************************************************************/


void
Bindable::GenMyGroupCollectionGetCode
(
    BCSYM_SyntheticMethod *SyntheticGet, // [in] the method that we will generate code for
    StringBuffer * CodeBlockText // [out] code for the synthetic get
)
{

    BCSYM_Class* GroupMemberClass = SyntheticGet->GetAssociatedPropertyDef()->GetType()->PClass();
    STRING *TypeName = GroupMemberClass->GetGlobalQualifiedName();
    STRING *CollectionMemberName = SyntheticGet->GetAssociatedPropertyDef()->GetName();
    STRING* supportField = CurrentCompilerInstance()->ConcatStrings(
        CLS_MYGROUPCOLLECTION_FIELD_PREFIX,
        CollectionMemberName);

    WellKnownAttrVals::MyGroupCollectionData* groupCollectionData;
    SyntheticGet->GetAssociatedPropertyDef()->GetContainingClass()->GetPWellKnownAttrVals()->GetMyGroupCollectionData(&groupCollectionData);
    unsigned int index;
    if (!FindBaseInMyGroupCollection(GroupMemberClass, groupCollectionData, &index))
    {
        VSFAIL("Bad group member class, no base found");
        return;
    }
    WellKnownAttrVals::MyGroupCollectionBase* arrayBase = groupCollectionData->Array();
    VSASSERT( arrayBase[index].m_GroupName != 0 && arrayBase[index].m_CreateMethod !=0,
        "Missing GroupName or CreateMethod name in MyGroupCollection attribute");

    // |1 <m_Form1>         - name of the public field that keeps the instance
    // |2 <CreateInstance>  - name of creator method
    // |3 <Form1>           - name of the member class;

    //'Get()
    //    <m_Form1> = <CreateInstance>(Of<Form1>)(<m_Form1>)
    //    return <m_Form1>
    //'End Get
    const WCHAR *GenMyCodeTemplate =
        L"|1 = |2(Of |3)(|1)\r\n \
          return |1\r\n";


    ResStringRepl(
        GenMyCodeTemplate,
        CodeBlockText,
        supportField,
        MakeSafeName(
            CurrentCompilerInstance(),
            arrayBase[index].m_CreateMethod,
            false /*fAfterDot*/),
        MakeSafeName(
            CurrentCompilerInstance(),
            TypeName,
            false /*fAfterDot*/)
        );
}

void
Bindable::GenMyGroupCollectionSetCode
(
    BCSYM_SyntheticMethod *SyntheticSet, // [in] the method that we will generate code for
    StringBuffer * CodeBlockText // [out] code for the synthetic get
)
{
    BCSYM_Class* GroupMemberClass = SyntheticSet->GetAssociatedPropertyDef()->GetType()->PClass();
    STRING *TypeName = GroupMemberClass->GetGlobalQualifiedName();
    STRING *CollectionMemberName = SyntheticSet->GetAssociatedPropertyDef()->GetName();
    STRING* supportField = CurrentCompilerInstance()->ConcatStrings(
        CLS_MYGROUPCOLLECTION_FIELD_PREFIX,
        CollectionMemberName);
    WellKnownAttrVals::MyGroupCollectionData* groupCollectionData;
    SyntheticSet->GetAssociatedPropertyDef()->GetContainingClass()->GetPWellKnownAttrVals()->GetMyGroupCollectionData(&groupCollectionData);
    unsigned int index;
    if (!FindBaseInMyGroupCollection(GroupMemberClass, groupCollectionData, &index))
    {
        VSFAIL("Bad group member class, no base found");
        return;
    }
    WellKnownAttrVals::MyGroupCollectionBase* arrayBase = groupCollectionData->Array();
    VSASSERT( arrayBase[index].m_GroupName != 0 && arrayBase[index].m_DisposeMethod !=0,
        "Missing GroupName or DisposeMethod name in MyGroupCollection attribute");

    // |1 <Value>           - set argument
    // |2 <DisposeInstance> - name of dispose method
    // |3 <m_Form1>         - name of the public field that keeps the instance
    // |4 <Form1>           - name of the member class

    //'Set(ByVal <Value> As Form1)
    //    If <Value> Is <m_Form1>
    //        return
    //    End If
    //    If Not <Value> Is Nothing Then
    //        Throw New ArgumentException("Property can only be set to Nothing.")
    //    End If
    //    <DisposeInstance>(Of <Form1>)(<m_Form1>)
    //'End Set

    const WCHAR *GenMyCodeTemplate =
        L"If |1 IS |3\r\n \
            Return\r\n \
          End If\r\n \
          If |1 ISNOT Nothing Then\r\n \
             Throw New Global.System.ArgumentException(\"Property can only be set to Nothing\")\r\n \
          End If\r\n \
          |2(Of |4)(|3)\r\n";

    WCHAR *ParamName =  MakeSafeName(
            CurrentCompilerInstance(),
            SyntheticSet->GetFirstParam()->GetName(),
            false /*fAfterDot*/);

    ResStringRepl(
        GenMyCodeTemplate,
        CodeBlockText,
        ParamName,
        MakeSafeName(
            CurrentCompilerInstance(),
            arrayBase[index].m_DisposeMethod,
            false /*fAfterDot*/),
        supportField,
        MakeSafeName(
            CurrentCompilerInstance(),
            TypeName,
            false /*fAfterDot*/));
}

// MyGroup Collection properties generation is based on a list:
// m_daMyGroupCollectionInfo - keeps all the classes intended as MyGroups, with MyGroupCollection attribute
//      associated to each group there is a list of member classes of the group. THe list is kept together with the name
//      in the entries of m_daMyGroupCollectionInfo.
// All the classes that have a base whose name matches the first name specified by the attribute of some group become members of the group
// For each member of the group a property and a support field is generated in the MyGroup class
////
//A typical example is as follows:
//---
//Class Form1
//Inherits System.Windows.Forms.Form
//end class
//
//<MyGroupCollection("System.Windows.Forms.Form", "CreateInstance", "DisposeInstance", "My.MyProject.Forms"> _
//Class TheForms
//Private Shared Function CreateInstance(Of T As Form)(ByVal Instance As T) As T
//    If Instance Is Nothing OrElse Instance.IsDisposed Then
//        'Return New T()
//        Console.WriteLine("got it")
//        Return Instance
//    Else
//        Return Instance
//    End If
//End Function
//
//Private Sub DisposeInstance(Of T As Form)(ByRef Instance As T)
//    Console.WriteLine("closed it")
//    Instance.Close()
//    Instance = Nothing
//End Sub
//'*
//'* BEGIN GENERATED CODE
//'*
//Public m_Form1 As Form1
//Public Property Form1() As Form1
//    Get
//        ' The name "CreateInstance" below is taken from the attribute
//        m_Form1 = CreateInstance(Of Form1)(m_Form1)
//        Return m_Form1
//    End Get
//
//    ' The Set is not generated if there is no "DisposeInstance" argument in the attribute
//    Set(ByVal Value As Form1)
//        If Value Is m_Form1 Then
//            Return
//        End If
//        If Not Value Is Nothing Then
//            Throw New ArgumentException("Property can only be set to Nothing.")
//        End If
//
//        ' The name "DisposeInstance" below is taken from the attribute
//        DisposeInstance(Of Form1)(m_Form1)
//    End Set
//
//End Property
//
//'*
//'* END GENERATED CODE
//'*
//End Class

void
Bindable::GenSyntheticMyGroupCollectionProperties
(
 MyGroupCollectionInfo* pGroupInfo,
 CompilerProject* project
 )
{
    BCSYM_Class* Class = pGroupInfo->m_groupClass;

    if (Class->IsBindingDone())
    {
        VSFAIL("Class is binding done without MyGroupCollection properties being generated.");
        return;
    }

    ULONG count = pGroupInfo->m_daMyGroupMembers.Count();

    // Class has MyCollection attribute but check if it has at least one member. Otherwise there is nothing to generate
    if (count != 0)
    {
#if DEBUG
        // sanity check on the group
        VSASSERT( Class->GetPWellKnownAttrVals()->HasMyGroupCollectionData(), " Classes in ClassesWithMyGroupCollection list must have MyGroupCollection atribute");
        VSASSERT( Class->HasLocation(), "Why there is no location for a class under compilation");

        WellKnownAttrVals::MyGroupCollectionData* groupCollectionData;
        Class->GetPWellKnownAttrVals()->GetMyGroupCollectionData(&groupCollectionData);
        WellKnownAttrVals::MyGroupCollectionBase* arrayBase = groupCollectionData->Array();

        for (unsigned i = 0 ; i < groupCollectionData->Count(); i++)
        {
            VSASSERT( arrayBase[i].m_GroupName != 0, "Missing GroupName in MyGroupCollection attribute");
            VSASSERT( arrayBase[i].m_CreateMethod != 0, "Missing CreateMethod in MyGroupCollection attribute");
            //VSASSERT( arrayBase[i].m_DisposeMethod != 0, "Missing DisposeMethod in MyGroupCollection attribute");

        }
#endif //debug

        Bindable *BindableInstanceForContainer = Class->GetBindableInstance();
        NorlsAllocator  Scratch(NORLSLOC);


        // sort members to handle simple name clashes. Order doesn't matter, just having all the classes with the same simple name
        // grouped together helps decide in one step if mangling is necessary.
        // It is only a gain of  O(n*n) -> O(n*log(n))
        qsort(pGroupInfo->m_daMyGroupMembers.Array(), count, sizeof(BCSYM_Class *), SortSymbolsByNameAndLocation);

        BCSYM_Class** arrayOfMemberClasses = pGroupInfo->m_daMyGroupMembers.Array();

        bool mangleNames = false;
        for (unsigned i = 0; i < count; i++)
        {
            BCSYM_Class* memberClass = arrayOfMemberClasses[i];
            if (!BindableInstanceForContainer->IsAccessible(memberClass))
            {
                continue;
            }

            // members with the same simple name are grouped together.
            // if two adjacent members with the same simple name then use name mangling

            mangleNames =
                ( i > 0 &&
                    StringPool::IsEqual(memberClass->GetName(), arrayOfMemberClasses[i-1]->GetName())) ||
                (i < count-1 &&
                    StringPool::IsEqual(memberClass->GetName() , arrayOfMemberClasses[i+1]->GetName()));

            BindableInstanceForContainer->GenSyntheticMyGroupCollectionProperty(
                Class,
                memberClass,
                &Scratch,
                mangleNames);
        }
    }

//CompleteBinding:
    Class->SetBindingDone(true);
    Class->DeleteBindableInstance();

    return;
}

bool
Bindable::ConflictsWithOtherProperties
(
    BCSYM_Class * ContainerClass,
    BCSYM_Class * GroupMemberClass,
    _In_z_ STRING * CollectionCandidateClassName,
    bool hasSet
    )
{

    BCSYM_NamedRoot *ExistingMember = ContainerClass->SimpleBind( NULL, CollectionCandidateClassName);
    STRING *CollectionMemberGetName = CurrentCompilerInstance()->ConcatStrings( CLS_PROPERTY_GET_PREFIX, CollectionCandidateClassName);
    BCSYM_NamedRoot *ExistingMemberGet = ContainerClass->SimpleBind( NULL, CollectionMemberGetName);
    BCSYM_NamedRoot *ExistingMemberSet = NULL;
    if (hasSet)
    {
        STRING *CollectionMemberSetName = CurrentCompilerInstance()->ConcatStrings( CLS_PROPERTY_SET_PREFIX, CollectionCandidateClassName);
        ExistingMemberSet = ContainerClass->SimpleBind( NULL, CollectionMemberSetName);
    }
    STRING* supportField = CurrentCompilerInstance()->ConcatStrings(
        CLS_MYGROUPCOLLECTION_FIELD_PREFIX,
        CollectionCandidateClassName);
    BCSYM_NamedRoot *ExistingField = ContainerClass->SimpleBind( NULL, supportField);

    //For now let reject any clash. The new member is a synthetic property and no overloads or other members with the same name should
    // be allowed
    if (ExistingMember || ExistingMemberGet || ExistingMemberSet || ExistingField  )
    {
        BCSYM_NamedRoot *Symbol =
            ExistingMember ?  ExistingMember :
                              (ExistingMemberGet ?  ExistingMemberGet :
                                                    (ExistingMemberSet ? ExistingMemberSet : ExistingField ));

        // When reporting an error, CurrentErrorLog should not be used to get the errorlog for a class context other than the one for
        // which the bindable instance has been created. There are two reasons for this:
        //
        //  1. Bindable is container based, so currenterrorlog will only return the error log for entities within that bindable instance's
        //     container possibly spanning several partial entities across multiple files
        //
        //  2. Even if CurrentErrorLog were to return the errorlog, the problem with this is that the file containing the conflicting
        //     class would have already reached bound by this time.
        //
        // So the fix is to report the error in the conflicting class' file's current error table, possibly reporting this in the
        // CS_TypesEmitted error table and ensure that the TypesEmitted error table does not get purged when moving from CS_Bound to
        // CS_TypesEmitted.
        //
        // See Bug VSWhidbey 273696.
        //
        ReportErrorOnSymbol(
            ERRID_PropertyNameConflictInMyCollection,
            GroupMemberClass->GetErrorTableForContext(),    // See Bug VSWhidbey 273696
            GroupMemberClass,
            GroupMemberClass->GetName());
        return true;
    }

    return false;
}
STRING *
Bindable::GetMyGroupScrambledName
(
    BCSYM_Class * GroupMemberClass,
    NorlsAllocator * Scratch,
    Compiler * Compiler
)
{
    STRING* qualifiedName = GroupMemberClass->GetQualifiedName();

    // Microsoft 9/13/2004: We are allocating space to match that of an already allocated, NULL-terminated string,
    // and so we need not worry about overflow.
    size_t count = 1 + StringPool::StringLength(qualifiedName);
    WCHAR* ScratchQualifiedNameString = (WCHAR*)Scratch->Alloc(sizeof(WCHAR) * count);
    for (size_t i = 0; i < count; i++)
    {
        ScratchQualifiedNameString[i] = (L'.' == qualifiedName[i]) ? L'_' : qualifiedName[i];
    }
    return (Compiler->AddString(ScratchQualifiedNameString));
}

void
Bindable::GenSyntheticMyGroupCollectionProperty
(
    BCSYM_Class * ContainerClass,
    BCSYM_Class * GroupMemberClass,
    NorlsAllocator * Scratch,
    bool    mangleNames
)
{
    Compiler* Compiler = ContainerClass->GetCompiler();
    Symbols
        SymbolAllocator(
            Compiler,
            ContainerClass->GetCompilerFile()->SymbolStorage(),
            NULL,
            CurrentGenericBindingCache());

    VSASSERT( ContainerClass->GetPWellKnownAttrVals()->HasMyGroupCollectionData(), "Why started a synthetic member generation for a MyGroupCollection without an atribute?");
    WellKnownAttrVals::MyGroupCollectionData* groupCollectionData;
    ContainerClass->GetPWellKnownAttrVals()->GetMyGroupCollectionData(&groupCollectionData);

    STRING * CollectionMemberPropertyName;
    if (mangleNames)
    {
        CollectionMemberPropertyName = GetMyGroupScrambledName(GroupMemberClass, Scratch, Compiler);
    }
    else
    {
        CollectionMemberPropertyName = GroupMemberClass->GetName();
    }
    unsigned int index;
    if (!FindBaseInMyGroupCollection(GroupMemberClass, groupCollectionData, &index))
    {
        VSFAIL("Bad group member class, no base found");
        return;
    }
    WellKnownAttrVals::MyGroupCollectionBase* arrayBase = groupCollectionData->Array();

    if (ConflictsWithOtherProperties(ContainerClass, GroupMemberClass, CollectionMemberPropertyName, arrayBase[index].m_DisposeMethod != NULL/*hasSet*/) )
    {
        return;
    }

    //DECLFLAGS DeclarationFlags = DECLF_Public | DECLF_Shared;
    DECLFLAGS DeclarationFlags = DECLF_Public | DECLF_MyGroupGenerated;

    // 0. gen public field that keeps the instance, i.e: public m_Form1 As Form1
    STRING *CollectionMemberField = Compiler->ConcatStrings( CLS_MYGROUPCOLLECTION_FIELD_PREFIX, CollectionMemberPropertyName  );

    BCSYM_Variable *CollectionMemberVar = SymbolAllocator.AllocVariable( false /*no location*/, false /* no value */);

    SymbolAllocator.GetVariable( NULL,
                                   CollectionMemberField,
                                   CollectionMemberField,
                                   DECLF_Dim | DECLF_SpecialName | DECLF_Hidden | DeclarationFlags,
                                   VAR_Member,
                                   GroupMemberClass,  // type
                                   NULL,
                                   NULL,    // no list to put symbols on
                                   CollectionMemberVar );


    // 1. get


    STRING *CollectionMemberGetName = Compiler->ConcatStrings( CLS_PROPERTY_GET_PREFIX, CollectionMemberPropertyName  );
    BCSYM_SyntheticMethod *GetMethod = SymbolAllocator.AllocSyntheticMethod(false  /* HasLocation ?*/);
    SymbolAllocator.GetProc(
        NULL,
        CollectionMemberGetName,
        CollectionMemberGetName, // the emitted name
        ( CodeBlockLocation* ) NULL,
        ( CodeBlockLocation* ) NULL,
        DECLF_PropGet | DECLF_SpecialName | DECLF_Hidden |DeclarationFlags,
        GroupMemberClass,  // ret type
        NULL, // no parameters
        NULL, // no param return
        NULL, // no lib name
        NULL, // no alias name
        SYNTH_MyGroupCollectionGet,
        NULL,  // no generic params
        NULL,  // no list to put symbols on
        GetMethod);

    // 2. set ( only if a dispose method is present)
    BCSYM_SyntheticMethod *SetMethod = NULL;
    if ( arrayBase[index].m_DisposeMethod != NULL)
    {
        BCSYM_Param *ParamFirst = NULL, *LastParam = NULL;
        STRING *CollectionMemberSetName = Compiler->ConcatStrings( CLS_PROPERTY_SET_PREFIX, CollectionMemberPropertyName  );
        SetMethod = SymbolAllocator.AllocSyntheticMethod(false  /* HasLocation ?*/);

        SymbolAllocator.GetParam( NULL, // no location
            Compiler->AddString( WIDE( "Value" )),
            GroupMemberClass,
            NULL,
            NULL,
            &ParamFirst,
            &LastParam,
            false);  // Not a return type param

        SymbolAllocator.GetProc(
            NULL,
            CollectionMemberSetName,
            CollectionMemberSetName, // the emitted name
            ( CodeBlockLocation* ) NULL,
            ( CodeBlockLocation* ) NULL,
            DECLF_PropSet | DECLF_SpecialName | DECLF_Hidden |DeclarationFlags,
            NULL,  // ret type
            ParamFirst, // 'Value As Form1'
            NULL, // no param return
            NULL, // no lib name
            NULL, // no alias name
            SYNTH_MyGroupCollectionSet,
            NULL,  // no generic params
            NULL,  // no list to put symbols on
            SetMethod);
    }

    // 3. [Property] symbol that holds the get/set(if any)
    BCSYM_Property *PropertySymbol = SymbolAllocator.AllocProperty(false   /* HasLocation ?*/);

    // Builds the proc into the base class portion of our PropertySymbol
    SymbolAllocator.GetProc(
        NULL,
        CollectionMemberPropertyName,
        CollectionMemberPropertyName, // the emitted name
        ( CodeBlockLocation* ) NULL,
        ( CodeBlockLocation* ) NULL,
        DeclarationFlags  | DECLF_Function | DECLF_HasRetval ,
        GroupMemberClass,
        NULL, // no parameters
        NULL, // no param return
        NULL, // not lib name
        NULL, // no alias name
        SYNTH_None,
        NULL, // no generic params
        NULL, // don't hang it off a symbol list - it belongs to the base class of the property symbol
        PropertySymbol->GetPropertySignature()); // Fills out the base class of the BCSYM_Property

    SymbolAllocator.GetProperty(
        NULL,
        CollectionMemberPropertyName,
        DeclarationFlags | (SetMethod ? DECLF_NoFlags : DECLF_ReadOnly),
        GetMethod,
        SetMethod,
        PropertySymbol,
        NULL   // no list to add on
        );


    // Add the field and property to the container's hash
    //
   Symbols::AddSymbolToHash(
        ContainerClass->GetHash(),
        CollectionMemberVar,
        true,       // set the parent of this member
        ContainerClass->IsStdModule(),
        false);     // container is not namespace

    Symbols::AddSymbolToHash(
        ContainerClass->GetHash(),
        PropertySymbol,
        true,       // set the parent of this member
        ContainerClass->IsStdModule(),
        false);     // container is not namespace


    VSASSERT( ContainerClass->GetUnBindableChildrenHash(),
                "How can a class not have an unbindable members hash ?");

    // Add the get accessor of the Property  to the container's unbindable members hash
    //

    Symbols::AddSymbolToHash(
        ContainerClass->GetUnBindableChildrenHash(),
        PropertySymbol->GetProperty(),
        true,       // set the parent of this member
        ContainerClass->IsStdModule(),
        false);     // container is not namespace

    GenSyntheticCode(PropertySymbol->GetProperty()->PSyntheticMethod());

    if (SetMethod)
    {
        Symbols::AddSymbolToHash(
            ContainerClass->GetUnBindableChildrenHash(),
            PropertySymbol->SetProperty(),
            true,       // set the parent of this member
            ContainerClass->IsStdModule(),
            false);     // container is not namespace
        GenSyntheticCode(PropertySymbol->SetProperty()->PSyntheticMethod());
    }


#if IDE

    // Add these to the list of symbols created in bindable.
    // This list is used to delete these from their respective hashes during decompilation
    // from bindable.
    //
    SymbolAllocator.GetAliasOfSymbol(
        PropertySymbol,
        ACCESS_Private,
        ContainerClass->GetBindableSymbolList());

    SymbolAllocator.GetAliasOfSymbol(
        PropertySymbol->GetProperty(),
        ACCESS_Private,
        ContainerClass->GetBindableSymbolList());

    if (SetMethod)
    {
        SymbolAllocator.GetAliasOfSymbol(
            PropertySymbol->SetProperty(),
            ACCESS_Private,
            ContainerClass->GetBindableSymbolList());
    }

    SymbolAllocator.GetAliasOfSymbol(
        CollectionMemberVar,
        ACCESS_Private,
        ContainerClass->GetBindableSymbolList());
#endif

}


#if DEBUG

const CHAR *SYNTH_NEW_CONTEXT_NAME = "SYNTH_New";
const CHAR *SYNTH_SHAREDNEW_CONTEXT_NAME = "SYNTH_SharedNew";
const CHAR *SYNTH_FORMMAIN_CONTEXT_NAME = "SYNTH_FormMain";
const CHAR *SYNTH_WITHEVENTSGET_CONTEXT_NAME = "SYNTH_WithEventsGet";
const CHAR *SYNTH_WITHEVENTSSET_CONTEXT_NAME = "SYNTH_WithEventsSet";
const CHAR *SYNTH_ADDEVENT_CONTEXT_NAME = "SYNTH_AddEvent";
const CHAR *SYNTH_REMOVEEVENT_CONTEXT_NAME = "SYNTH_RemoveEvent";
const CHAR *SYNTH_MYGROUPGET_CONTEXT_NAME = "SYNTH_MyGroupGet";
const CHAR *SYNTH_MYGROUPCOLLECTIONGET_CONTEXT_NAME = "SYNTH_MyGroupCollectionGet";
const CHAR *SYNTH_MYGROUPCOLLECTIONSET_CONTEXT_NAME = "SYNTH_MyGroupCollectionSet";
const CHAR *SYNTH_TRANSIENTSYMBOL_CONTEXT_NAME = "SYNTH_TransientSymbol";
const CHAR *SYNTH_TRANSIENTNOINTCHECKSYMBOL_CONTEXT_NAME = "SYNTH_TransientNoIntCheckSymbol";

#if IDE
const CHAR *SYNTH_ITERATEENCTRACKINGLIST_CONTEXT_NAME = "SYNTH_IterateENCTrackingList";
const CHAR *SYNTH_ENCUPDATEHANDLER_CONTEXT_NAME = "SYNTH_ENCUpdateHandler";
const CHAR *SYNTH_ENCHIDDENREFRESH_CONTEXT_NAME = "SYNTH_ENCHiddenRefresh";
const CHAR *SYNTH_ENCSHAREDHIDDENREFRESH_CONTEXT_NAME = "SYNTH_ENCSharedHiddenRefresh";
const CHAR *SYNTH_ADDTOENCTRACKINGLIST_CONTEXT_NAME = "SYNTH_AddToENCTrackingList";
#endif IDE

const CHAR *
GetSyntheticContextName
(
    SyntheticKind Kind
)
{
    switch(Kind)
    {
        case SYNTH_New:
            return SYNTH_NEW_CONTEXT_NAME;

        case SYNTH_SharedNew:
            return SYNTH_SHAREDNEW_CONTEXT_NAME;

        case SYNTH_FormMain:
            return SYNTH_FORMMAIN_CONTEXT_NAME;

        case SYNTH_WithEventsGet:
            return SYNTH_WITHEVENTSGET_CONTEXT_NAME;

        case SYNTH_WithEventsSet:
            return SYNTH_WITHEVENTSSET_CONTEXT_NAME;

        case SYNTH_AddEvent:
            return SYNTH_ADDEVENT_CONTEXT_NAME;

        case SYNTH_RemoveEvent:
            return SYNTH_REMOVEEVENT_CONTEXT_NAME;

        case SYNTH_MyGroupCollectionGet:
            return SYNTH_MYGROUPCOLLECTIONGET_CONTEXT_NAME;

        case SYNTH_MyGroupCollectionSet:
            return SYNTH_MYGROUPCOLLECTIONSET_CONTEXT_NAME;

        case SYNTH_TransientSymbol:
            return SYNTH_TRANSIENTSYMBOL_CONTEXT_NAME;

        case SYNTH_TransientNoIntCheckSymbol:
            return SYNTH_TRANSIENTNOINTCHECKSYMBOL_CONTEXT_NAME;

#if IDE
        case SYNTH_IterateENCTrackingList:
            return SYNTH_ITERATEENCTRACKINGLIST_CONTEXT_NAME;

        case SYNTH_ENCUpdateHandler:
            return SYNTH_ENCUPDATEHANDLER_CONTEXT_NAME;

        case SYNTH_ENCHiddenRefresh:
            return SYNTH_ENCHIDDENREFRESH_CONTEXT_NAME;

        case SYNTH_ENCSharedHiddenRefresh:
            return SYNTH_ENCSHAREDHIDDENREFRESH_CONTEXT_NAME;

        case SYNTH_AddToENCTrackingList:
            return SYNTH_ADDTOENCTRACKINGLIST_CONTEXT_NAME;
#endif IDE

        default:

            VSFAIL("Unknown Synthetic kind");
            return "";
            break;
    }
}

#endif

